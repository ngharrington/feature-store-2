./app.py
<app.py content>
from fastapi import FastAPI, HTTPException, status, Depends
from config import get_event_properties_map
from services.event_registry import EventSchemaRegistry, EventTypeNotRegistered
from services.event_processer import EventProcessor, EventConsumer
from models.event import Event
import asyncio
from contextlib import asynccontextmanager


NUM_CONSUMERS = 25

event_queue = asyncio.Queue()


def _initialize_schema_registry():
    event_schema_registry = EventSchemaRegistry()
    event_properties_map = get_event_properties_map()
    for event_name, event_properties in event_properties_map.items():
        event_schema_registry.register_event_properties_schema(event_name, event_properties)
    return event_schema_registry

schema_registry = _initialize_schema_registry()

def get_schema_registry():
    return schema_registry


@asynccontextmanager
async def lifespan(app: FastAPI):
    event_processor = EventProcessor()
    consumer = EventConsumer(
        queue=event_queue,
        event_processor=event_processor
    )
    consumer_tasks = [asyncio.create_task(consumer.consume()) for _ in range(NUM_CONSUMERS)]
    yield

    await event_queue.join()
    for task in consumer_tasks:
        task.cancel()
    await asyncio.gather(*consumer_tasks, return_exceptions=True)

app = FastAPI(lifespan=lifespan)


@app.get("/")
async def read_root():
    return {"Hello": "World"}


@app.post("/event")
async def publish_event(event: Event):
    try:
        event_properties_schema = await schema_registry.get_schema_by_name(event.name)
    except EventTypeNotRegistered as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))
    
    if not isinstance(event.event_properties, dict):
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=f"Invalid event format for event type {event.name}")
    
    parsed_event = Event(
        uuid=event.uuid,
        name=event.name,
        timestamp=event.timestamp,
        event_properties=event_properties_schema(**event.event_properties)
    )

    await event_queue.put(parsed_event)
    return {"event_id": event.uuid}

@app.get("/queue-size")
async def get_queue_size():
    """
    Endpoint to return the current size of the event queue.
    """
    try:
        queue_size = event_queue.qsize()
        return {"queue_size": queue_size}
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get queue size: {str(e)}"
        )


./config.py
<config.py content>
from models.event import ScamFlagEventProperties, AddCreditCardEventProperties, ChargebackEventProperties
from models.aggregate import EventAggregateConfig
from services.event_registry import EventSchemaRegistry

class ConfigError(Exception):
    pass

def get_event_properties_map():
    return {
        "scam_flag": ScamFlagEventProperties,
        "add_credit_card": AddCreditCardEventProperties,
        "chargeback": ChargebackEventProperties,
    }


def validate_event_aggregate_config(config: EventAggregateConfig, schema_registry: EventSchemaRegistry):
    schema = schema_registry.event_schemas.get(config.event_name)
    if config.field and not hasattr(schema, config.field):
        raise ConfigError(f"Field '{config.field}' not found in event properties schema for event '{config.event_name}'")


./models/__init__.py
<__init__.py content>



./models/event.py
<event.py content>
from pydantic import BaseModel, field_validator
import uuid
from datetime import datetime
from typing import Dict, Any

class EventPropertiesBase(BaseModel):
    user_id: str

class ScamFlagEventProperties(EventPropertiesBase):
    pass

class AddCreditCardEventProperties(EventPropertiesBase):
    zipcode: str

class ChargebackEventProperties(EventPropertiesBase):
    amount: float
    total_spend: float

class Event(BaseModel):
    uuid: uuid.UUID
    name: str
    timestamp: datetime
    event_properties: Any




./models/aggregate.py
<aggregate.py content>
import asyncio
import enum
from dataclasses import dataclass
from models.event import Event
from typing import Type
from collections import defaultdict
from typing import Dict, List
from pydantic import BaseModel

class AggregationError(Exception):
    pass

class AggregateType(enum.Enum):
    COUNT = "count"
    DISTINCT_COUNT = "distinct_count"
    SUM = "sum"

@dataclass
class EventAggregateConfig:
    type: AggregateType
    name: str
    event_name: str
    field: str = None

    def __post_init__(self):
        if self.type == AggregateType.COUNT and self.field:
            raise ValueError("Field is not required for COUNT aggregate type.")
        elif (
            self.type in (AggregateType.SUM, AggregateType.DISTINCT_COUNT)
            and not self.field
        ):
            raise ValueError(
                "Field is required for SUM or DISTINCT_COUNT aggregate type."
            )

class EventAggregate:

    def __init__(self, name: str, event_name: str, type: AggregateType, field: str = None):
        self.name = name
        self.event_name = event_name
        self.type = type
        self.field = field
        self.value = 0
        self._store = defaultdict(self._initial_value)

    def update(self, user_id: str, event: Event):
        if self.type == AggregateType.COUNT:
            self._store[user_id] += 1
        elif self.type == AggregateType.SUM:
            self._store[user_id] += self._get_event_field_value(event)
        elif self.type == AggregateType.DISTINCT_COUNT:
            self._store[user_id].add(self._get_event_field_value(event))

    def get_user_aggregate(self, user_id: str):
        if self.type in (AggregateType.COUNT, AggregateType.SUM):
            return self._store.get(user_id, 0)
        elif self.type == AggregateType.DISTINCT_COUNT:
            return len(self._store.get(user_id, set()))
        else:
            raise ValueError("Invalid aggregate type.")

    def _get_event_field_value(self, event):
        val = getattr(event.event_properties, self.field, None)
        if not val:
            raise AggregationError(
                f"Field '{self.field}' not found in event properties."
            )
        return val

    def _initial_value(self):
        if self.type == AggregateType.DISTINCT_COUNT:
            return set()
        return 0
    

class EventAggregateStore:
    def __init__(self):
        self._store: Dict[str, EventAggregate] = {}
        self._lock = asyncio.Lock()
        self._event_lookup: Dict[str, BaseModel] = {}

    def add_aggregate(self, aggregate: EventAggregate):
        if aggregate.name in self._store:
            raise AggregationError(f"Aggregate {aggregate.name} already exists.")
        self._store[aggregate.name] = aggregate
        self._index_on_event_name(aggregate)

    async def get_aggregates_by_event_name(self, event_name: str) -> List[EventAggregate]:
        async with self._lock:
            return self._event_lookup.get(event_name, [])

    async def get_aggregate_by_name(self, name: str) -> EventAggregate:
        async with self._lock:
            if name not in self._store:
                raise ValueError(f"Aggregate {name} not found.")
            return self._store[name]


    def _index_on_event_name(self, aggregate: EventAggregate):
        if aggregate.event_name not in self._event_lookup:
            self._event_lookup[aggregate.event_name] = []
        self._event_lookup[aggregate.event_name].append(aggregate)



./services/event_registry.py
<event_registry.py content>
from models import event
from typing import Type
import asyncio

class EventTypeNotRegistered(Exception):
    pass

class EventAlreadyRegistered(Exception):
    pass

class EventSchemaRegistry:
    def __init__(self):
        self.event_schemas = {}
        self._lock = asyncio.Lock()

    async def get_schema_by_name(self, event_name: str) -> Type[event.Event]:
        async with self._lock:
            if event_name not in self.event_schemas:
                raise EventTypeNotRegistered(f"Event {event_name} not registered")
            return self.event_schemas[event_name]
        
    
    def register_event_properties_schema(self, event_name: str, event_schema: Type[event.Event]):
        # this is read-only after initialization of the app so no need for a lock
        if event_name in self.event_schemas:
            raise EventAlreadyRegistered(f"Event {event_name} already registered")
        self.event_schemas[event_name] = event_schema

    


./services/event_processer.py
<event_processer.py content>
import asyncio

from models.event import Event

class EventProcessor:
    def __init__(self):
        pass

    async def process_event(self, event: Event):
        print(f"Event {event.uuid} processed")


class EventConsumer:
    def __init__(self, queue: asyncio.Queue, event_processor: EventProcessor):
        self.queue = queue
        self.event_processor = event_processor

    async def consume(self):
        try:
            while True:
                print("waiting")
                item = await self.queue.get()
                print("got item")
                await self.event_processor.process_event(item)
                self.queue.task_done()
        except asyncio.CancelledError:
            print("Consumer cancelled")
            return
        except Exception as e:
            print(f"Consumer error: {e}")
            raise



./tests/conftest.py
<conftest.py content>
import sys
from pathlib import Path

root_dir = Path(__file__).resolve().parent.parent
sys.path.insert(0, str(root_dir))



./tests/test_aggregates.py
<test_aggregates.py content>



